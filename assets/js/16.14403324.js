(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{520:function(t,e,a){"use strict";a.r(e);var r=a(6),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[t._v("#")]),t._v(" 1")]),t._v(" "),a("h3",{attrs:{id:"jsx和html的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx和html的区别"}},[t._v("#")]),t._v(" JSX和html的区别")]),t._v(" "),a("ol",[a("li",[t._v("JSX中的元素不局限于html中的元素，可以是任何一个React组件。")]),t._v(" "),a("li",[t._v("JSX中可以通过onclick这样的方式给一个元素添加一个事件处理函数，但在html中会造成代码混乱。")])]),t._v(" "),a("h3",{attrs:{id:"html中直接使用onclick会带来的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html中直接使用onclick会带来的问题"}},[t._v("#")]),t._v(" Html中直接使用onclick会带来的问题")]),t._v(" "),a("ol",[a("li",[t._v("onclick添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意想不到的后果。")]),t._v(" "),a("li",[t._v("给很多DOM元素添加事件会影响网页的性能")]),t._v(" "),a("li",[t._v("对于使用onclick的DOM元素，如果要动态地从DOM中删除，需要把对应的时间处理器注销，如果忘了注销，可能会造成内存泄漏。")])]),t._v(" "),a("h3",{attrs:{id:"jsx使用onclick的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx使用onclick的过程"}},[t._v("#")]),t._v(" JSX使用onclick的过程")]),t._v(" "),a("p",[t._v("无论有多少个onclick出现，最后都只在DOM树上添加了一个事件处理函数，挂在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定函数，性能也因此高。")]),t._v(" "),a("blockquote",[a("p",[t._v("react的组件可以把js、html、css的功能在一个文件中，实现真正的组件封装。")])]),t._v(" "),a("h3",{attrs:{id:"react和jquery的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react和jquery的区别"}},[t._v("#")]),t._v(" React和Jquery的区别")]),t._v(" "),a("p",[t._v("React更加智能化，不需要事无巨细。能把开发者从繁琐的操作中解放。")]),t._v(" "),a("h3",{attrs:{id:"react的理念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react的理念"}},[t._v("#")]),t._v(" React的理念")]),t._v(" "),a("p",[t._v("$$\nUI = render(data)\n$$")]),t._v(" "),a("h3",{attrs:{id:"react工作方式的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react工作方式的优点"}},[t._v("#")]),t._v(" React工作方式的优点")]),t._v(" "),a("ol",[a("li",[t._v("开发者效率大大提高")]),t._v(" "),a("li",[t._v("代码维护性和可阅读性也大大增强")])]),t._v(" "),a("h2",{attrs:{id:"_2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2"}},[t._v("#")]),t._v(" 2")]),t._v(" "),a("blockquote",[a("p",[t._v("尽量保证一个组件只做一件事")])]),t._v(" "),a("h3",{attrs:{id:"组件的划分要满足"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件的划分要满足"}},[t._v("#")]),t._v(" 组件的划分要满足")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("高内聚")]),t._v("：把逻辑关系紧密的内容放到一个组件中（react有天生的高内聚的特点）")]),t._v(" "),a("li",[a("strong",[t._v("低耦合")]),t._v("：不同组件之间的依赖关系要弱化，每个组件要尽量独立。")])]),t._v(" "),a("h3",{attrs:{id:"react组件的数据分两种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react组件的数据分两种"}},[t._v("#")]),t._v(" React组件的数据分两种")]),t._v(" "),a("p",[t._v("prop和state，prop是组件的对外接口，state是组件的内部状态。对外prop，对内state。")]),t._v(" "),a("h3",{attrs:{id:"proptypes检查"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proptypes检查"}},[t._v("#")]),t._v(" propTypes检查")]),t._v(" "),a("p",[t._v("propTypes检查只是一个辅助开发的工具，不会影响改变组件的行为。")]),t._v(" "),a("h3",{attrs:{id:"为什么用this-setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么用this-setstate"}},[t._v("#")]),t._v(" 为什么用this.setState()")]),t._v(" "),a("p",[t._v("因为直接改动state状态不能触发重新渲染，而setState帮助了重新渲染。")]),t._v(" "),a("h3",{attrs:{id:"prop和state的对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prop和state的对比"}},[t._v("#")]),t._v(" Prop和State的对比")]),t._v(" "),a("ul",[a("li",[t._v("prop用于定义外部接口，state用于记录内部状态")]),t._v(" "),a("li",[t._v("prop的赋值在外部世界使用组件时，state的赋值在组件内部")]),t._v(" "),a("li",[t._v("组件不应该改变prop的值，而state存在的目的就是让组件改变的")])]),t._v(" "),a("h3",{attrs:{id:"组件的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件的生命周期"}},[t._v("#")]),t._v(" 组件的生命周期")]),t._v(" "),a("ul",[a("li",[t._v("装载过程（Mount）：组件第一次在DOM树中渲染的过程")]),t._v(" "),a("li",[t._v("更新过程（Update）：组件重新被渲染的过程")]),t._v(" "),a("li",[t._v("卸载过程（Unmount）：组件从DOM中删除的过程")])]),t._v(" "),a("h3",{attrs:{id:"装载过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装载过程"}},[t._v("#")]),t._v(" 装载过程")]),t._v(" "),a("h4",{attrs:{id:"constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),a("p",[t._v("一个React组件需要构造函数，往往是为了下面的目的：")]),t._v(" "),a("ol",[a("li",[t._v("初始化State，因为组件生命周期中任何函数都可能要访问State，整个生命周期中第一个被调用的构造函数是初始化State最理想的地方。")]),t._v(" "),a("li",[t._v("绑定成员函数的this环境。")])]),t._v(" "),a("h4",{attrs:{id:"getinitialstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getinitialstate"}},[t._v("#")]),t._v(" getInitialState")]),t._v(" "),a("p",[t._v("整个生命周期中这个函数只被调用一次。")]),t._v(" "),a("h5",{attrs:{id:"给state初始化的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#给state初始化的方法"}},[t._v("#")]),t._v(" 给State初始化的方法")]),t._v(" "),a("ul",[a("li",[t._v("getInitialState函数")]),t._v(" "),a("li",[t._v("给类属性defaultProps赋值指定初始值")])]),t._v(" "),a("h4",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" render")]),t._v(" "),a("p",[t._v("render函数是React组件中必须实现的部分。因为所有React组件的父类React.Component类对除了render以外的生命周期函数都有默认实现。")]),t._v(" "),a("p",[t._v("通常一个组件要发挥作用，总要渲染一些东西，render函数并不做实际的渲染动作，知识返回一个JSX描述的结构，最终由React来操作渲染过程。")]),t._v(" "),a("p",[t._v("如果某些特殊组件不是渲染页面，或者在某些情况下选择没有东西可画，那就让render函数返回一个null或者false，等于告诉React，这个组件这次不需要渲染任何DOM元素。")]),t._v(" "),a("p",[t._v("render函数应当是一个纯函数，纯函数不应引起状态的变化。所以不可能在render函数中去调用this.setState。")]),t._v(" "),a("h4",{attrs:{id:"componentwillmount和componentdidmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillmount和componentdidmount"}},[t._v("#")]),t._v(" componentWillMount和componentDidMount")]),t._v(" "),a("p",[t._v("componentWillMount在调用render函数之前被调用，componentDidMount在render函数调用之后调用。")]),t._v(" "),a("p",[t._v("通常不定义componentWillMount函数，因为即使这时候修改了状态渲染也不会发生改变，为时已晚。可以认为这个函数存在就是为了和componentDidMount对称。")]),t._v(" "),a("p",[t._v("只有 React 库调用组件的 render 函数之后，才有可能完成装载，这时候才会依次调用各个组件的 componentDidMount 函数作为装载过程的收尾。")]),t._v(" "),a("h5",{attrs:{id:"componentwilimount-componentdidmount的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwilimount-componentdidmount的区别"}},[t._v("#")]),t._v(" componentWilIMount componentDidMount的区别")]),t._v(" "),a("p",[t._v("这对兄弟函数还有一个区别，就是 componentWillMount 可以在服务器端被调用，也可以在浏览器端被调用；而 componentDidMount只能在浏览器端被调用，在服务器端使用 React 的时候不会被调用。")]),t._v(" "),a("h3",{attrs:{id:"更新过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新过程"}},[t._v("#")]),t._v(" 更新过程")]),t._v(" "),a("ul",[a("li",[t._v("componentWillReceiveProps")]),t._v(" "),a("li",[t._v("shouldComponentUpdate")]),t._v(" "),a("li",[t._v("componentWillUpdate")]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("componentDidUpdate")])]),t._v(" "),a("h4",{attrs:{id:"componentwillreceiveprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillreceiveprops"}},[t._v("#")]),t._v(" componentWillReceiveProps")]),t._v(" "),a("p",[t._v("只要是父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给自组件的props有没有变化，都会触发自组件的componentWillReceiveProps函数。")]),t._v(" "),a("p",[t._v("注意，通过 this.setState 方法触发的更新过程不会调用这个函数，这是因为这个函数适合根据新的 props 值（也就是参数 nextProps ）来计算出是不是要更新内部状态 state 更新组件内部状态的方法就是 this.setState ，如果 this.setState 的调用导致 componentWillReceiveProps 次被调用，那就是一个死循环了")]),t._v(" "),a("h4",{attrs:{id:"shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate"}},[t._v("#")]),t._v(" shouldComponentUpdate")]),t._v(" "),a("p",[t._v("render函数重要，是因为 render 函数决定了该渲染什么，而说 shouldComponentUpdate 函数重要，是因为它决定了一个组件什么时候不需要渲染。render和shouldComponentUpdate 函数，也是 React 生命周期函数中唯两个要求有返回结果的函数。")]),t._v(" "),a("h4",{attrs:{id:"componentwillupdate和componentdidupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillupdate和componentdidupdate"}},[t._v("#")]),t._v(" componentWillUpdate和componentDidUpdate")]),t._v(" "),a("p",[t._v("和装载过程不同的是，当在服务器端使用React渲染时，这一对函数中的Did函数，也就是componentDidMount函数，并不只是在浏览器端才执行的，无论更新过程发生在服务器端还是浏览器端，该函数都会被调用。")]),t._v(" "),a("h3",{attrs:{id:"卸载过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#卸载过程"}},[t._v("#")]),t._v(" 卸载过程")]),t._v(" "),a("ul",[a("li",[t._v("componentWillUnmount")])]),t._v(" "),a("p",[t._v("当React组件要从DOM树上删除之前，对应的componentWillUnmount函数会被调用，所以改函数适合做一些清理性的工作。")]),t._v(" "),a("h2",{attrs:{id:"_3-flux和redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-flux和redux"}},[t._v("#")]),t._v(" 3 Flux和Redux")]),t._v(" "),a("h3",{attrs:{id:"mvc框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc框架"}},[t._v("#")]),t._v(" MVC框架")]),t._v(" "),a("ul",[a("li",[t._v("Model负责管理数据")]),t._v(" "),a("li",[t._v("View负责渲染用户界面")]),t._v(" "),a("li",[t._v("Controller负责接受用户输入")])]),t._v(" "),a("h3",{attrs:{id:"flux框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flux框架"}},[t._v("#")]),t._v(" Flux框架")]),t._v(" "),a("div",{staticClass:"language-mermaid line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("graph LR\n\tAction--\x3eDispatcher--\x3eStore--\x3eView \n\tView--\x3eDispatcher\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("ul",[a("li",[t._v("Action驱动Disapatcher和JavaScript对象")]),t._v(" "),a("li",[t._v("Dispatcher处理动作的分发，维持Store之间的依赖关系。")]),t._v(" "),a("li",[t._v("Store负责存储数据和处理数据的相关逻辑")]),t._v(" "),a("li",[t._v("View负责显示用户界面")])]),t._v(" "),a("h3",{attrs:{id:"redux的基本原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux的基本原则"}},[t._v("#")]),t._v(" Redux的基本原则")]),t._v(" "),a("ul",[a("li",[t._v("唯一数据源")]),t._v(" "),a("li",[t._v("单向数据流")]),t._v(" "),a("li",[t._v("保持状态只读")]),t._v(" "),a("li",[t._v("数据改变只能通过纯函数完成")])]),t._v(" "),a("h4",{attrs:{id:"唯一数据源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#唯一数据源"}},[t._v("#")]),t._v(" 唯一数据源")]),t._v(" "),a("p",[t._v("应用的状态数据只存储在唯一的一个store上。")]),t._v(" "),a("p",[t._v("如果状态数据分散在多个Store上，容易造成数据冗余，这样数据一致性就会出问题。")]),t._v(" "),a("p",[t._v("这个唯一Store上的状态，是一个树形的对象，每个组件往往只是树形对象上一部分的数据。而如何设计Store上状态的结构，就是Redux应用的核心问题。")]),t._v(" "),a("blockquote",[a("p",[t._v("redux没有阻止多个Store，但真没必要。")])]),t._v(" "),a("h4",{attrs:{id:"保持状态只读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保持状态只读"}},[t._v("#")]),t._v(" 保持状态只读")]),t._v(" "),a("p",[t._v("不直接去修改状态，要修改Store的状态，必须要通过派发一个action对象完成。")]),t._v(" "),a("p",[t._v("为了驱动用户界面渲染，就要改变应用的状态，但改变的方法不是修改状态的值，而是通过重新创建一个新的状态对象给Redux，并由Redux完成新状态的组装。")]),t._v(" "),a("h4",{attrs:{id:"数据改变只能通过纯函数完成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据改变只能通过纯函数完成"}},[t._v("#")]),t._v(" 数据改变只能通过纯函数完成")]),t._v(" "),a("p",[t._v("按照创作者 Dan Abramov 的说法， Redux 的含义是 Reducer+Flux。")]),t._v(" "),a("h3",{attrs:{id:"在redux中使用解构赋值的意义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在redux中使用解构赋值的意义"}},[t._v("#")]),t._v(" 在redux中使用解构赋值的意义")]),t._v(" "),a("p",[t._v("它使得处理单向数据流更加容易。")]),t._v(" "),a("p",[t._v("不可变原则禁止修改对象。幸运的是，解构可以帮助你在遵循不可变原则的同时完成这些操作。")]),t._v(" "),a("p",[t._v("https://www.jb51.net/article/169392.htm")]),t._v(" "),a("h3",{attrs:{id:"redux中设计store的主要原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux中设计store的主要原则"}},[t._v("#")]),t._v(" Redux中设计store的主要原则")]),t._v(" "),a("p",[t._v("避免冗余的数据")]),t._v(" "),a("h3",{attrs:{id:"什么是纯函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是纯函数"}},[t._v("#")]),t._v(" 什么是纯函数")]),t._v(" "),a("p",[t._v("简单来说，一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。这么说肯定比较抽象，我们把它掰开来看：")]),t._v(" "),a("ul",[a("li",[t._v("函数的返回结果只依赖于它的参数。")]),t._v(" "),a("li",[t._v("函数执行过程里面没有副作用。（它不能改变任何外部状态）")])]),t._v(" "),a("p",[t._v("为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。")]),t._v(" "),a("h3",{attrs:{id:"一个react组件基本上就是要完成以下两个功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个react组件基本上就是要完成以下两个功能"}},[t._v("#")]),t._v(" 一个React组件基本上就是要完成以下两个功能")]),t._v(" "),a("ul",[a("li",[t._v("和Redux Store打交道，读取Store的状态，用于初始化组件的状态，同时还要监听Store的状态变化；当Store状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新Store状态时，就要派发action对象。")]),t._v(" "),a("li",[t._v("根据props和state渲染出用户界面。")])]),t._v(" "),a("h3",{attrs:{id:"容器组件和展示组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#容器组件和展示组件"}},[t._v("#")]),t._v(" 容器组件和展示组件")]),t._v(" "),a("p",[t._v("又叫作聪明组件和傻瓜组件")]),t._v(" "),a("div",{staticClass:"language-mermaid line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("graph LR\n\t容器组件--\x3eStore\n\t容器组件--传递props--\x3e傻瓜组件\n\t傻瓜组件--\x3eReact\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("在我们把一个组件拆分为容器组件和傻瓜组件的时候，不只是功能分离，还有一个 比较大的变化，那就是傻瓜组件不需要有状态了。")]),t._v(" "),a("p",[t._v("实际上，"),a("strong",[t._v("让傻瓜组件无状态")]),t._v("，是我们拆分的主要目的之一，傻瓜组件只需要根据 props 来渲染结果，不需要 state。"),a("strong",[t._v("状态通过props传递全交由容器组件处理")]),t._v("。")])])}),[],!1,null,null,null);e.default=s.exports}}]);